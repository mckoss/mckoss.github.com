<%

' Dictionary entries generated by XML parsing:
' T - Tag name (will be "/TAG" if closing tag)
' U - True for "unitary" tags - no body (e.g., <TAG/>)
' A:ATTRIB - Attribute values
' B - Concatenation of top level body text
' X:TAG - A sub-dictionary for embedded XML
' M:TAG - For tags that appear multiple times - this field gives the count.
'         Those beyond the first value are named X:TAG[N] for N = 1 to count-1.

Function ParseXML(st, ich, ByRef dict)
        Dim dictSub
        Dim stB
        Dim ch
        Dim ichLast
        Dim ichTag
        Dim ichEnd
        Dim isub

        TraceIn "ParseXML", "(" & ich & ")"

        HideTrace

        ichLast = Len(st)

        dict.CompareMode = 1

        ' Get top-level tag information
        ich = ScanTag(st, ich, dict)
        If ich < 0 Then
                ParseXML = ich
                TraceOut
                Exit Function
        End If

        ' Test for unitary or ending tag.
        If dict.Exists("U") Or Mid(dict.Item("T"), 1, 1) = "/" Then
                ParseXML = ich
                TraceOut
                Exit Function
        End If

        Do While ich <= ichLast
                ichTag = InStr(ich, st, "<")
                If (ichTag = 0) Then
                        ParseXML = -ich
                        TraceOut
                        Exit Function
                End If
                If (ich < ichTag) Then
                        If Mid(st, ich, 1) = """" Then
                            stB = stB & UnquoteString(st, ich)
                        Else
                            stB = stB & TrimSpace(Mid(st, ich, ichTag - ich))
                            ich = ichTag
                        End If
                Else
                        ' Handle comment <!--XXX--> and <![CDATA[XXX]]> here
                        If Mid(st, ich + 1, 1) = "!" Then
                                If Mid(st, ich, 4) = "<!--" Then
                                        ichEnd = InStr(ich, st, "-->")
                                        If ichEnd = 0 Then
                                                ParseXML = -ich
                                                TraceOut
                                                Exit Function
                                        End If
                                        ich = ichEnd + 3
                                ElseIf Mid(st, ich, 9) = "<![CDATA[" Then
                                        ichEnd = InStr(ich, st, "]]>")
                                        If ichEnd = 0 Then
                                                ParseXML = -ich
                                                TraceOut
                                                Exit Function
                                        End If
                                        stB = stB & Mid(st, ich + 9, ichEnd - (ich + 9))
                                        ich = ichEnd + 3
                                ' Ignore other extended tokens - assume no embedded '>'
                                Else
                                        ichEnd = InStr(ich, st, ">")
                                        If ichEnd = 0 Then
                                                ParseXML = -ich
                                                TraceOut
                                                Exit Function
                                        End If
                                        ich = ichEnd + 1
                                End If
                        Else
                                Set dictSub = CreateObject("Scripting.Dictionary")
                                ich = ParseXML(st, ich, dictSub)
                                If ich < 0 Then
                                        ParseXML = ich
                                        TraceOut
                                        Exit Function
                                End If

                                If Mid(dictSub.Item("T"), 1, 1) = "/" Then
                                        If Mid(dictSub.Item("T"), 2) <> dict.Item("T") Then
                                                ParseXML = -ich
                                                TraceOut
                                                Exit Function
                                        End If
                                        If stB <> "" Then
                                                dict.Item("B") = stB
                                        End If
                                        ParseXML = ich
                                        TraceOut
                                        Exit Function
                                End If
                                AddChildTag dict, dictSub
                        End If
                End If
        Loop
        ParseXML = -ich
End Function

sub AddChildTag(dictParent, dictChild)
	Dim isub

	TraceIn "AddChildTag", "(" & dictParent.Item("T") & ", " & dictChild.Item("T") & ")"
	
    If dictParent.Exists("X:" & dictChild.Item("T")) Then
        If dictParent.Exists("M:" & dictChild.Item("T")) Then
            isub = dictParent.Item("M:" & dictChild.Item("T"))
	    dictParent.Remove("M:" & dictChild.Item("T"))
        Else
            isub = 1
        End If
        isub = isub + 1
        dictParent.Add "M:" & dictChild.Item("T"), isub
        dictParent.Add "X:" & dictChild.Item("T") & "[" & isub - 1 & "]", dictChild
    Else
        dictParent.Add "X:" & dictChild.Item("T"), dictChild
    End If
    
    TraceOut
end sub

function CountTags(stTag, ByRef dict)
	dim iTag

	if dict.Exists("M:" & stTag) then
		iTag = dict.Item("M:" & stTag)
	elseif dict.Exists("X:" & stTag) then
		iTag = 1
	else
		iTag = 0
	end if

	CountTags = iTag
end function


' FSM for tag parsing (T, U, and A parse here)
Function ScanTag(st, ich, ByRef dict)
    Dim ichLast
    Dim state
    Dim stT
    Dim stA
    Dim stV
    Dim ch

    ichLast = Len(st)
    state = "A"
    Do While ich <= ichLast
            ch = Mid(st, ich, 1)
            ich = ich + 1
            Select Case state
            Case "A"        ' ""
                    If ch = "<" Then
                            state = "B"
                    Else
                            ScanTag = -ich
                            Exit Function
                    End If
            Case "B"        ' "<"
                    If IsSpace(ch) Then
                            If stT = "" Then
                                    ScanTag = -ich
                                    Exit Function
                            End If
                            dict.Item("T") = stT
                            state = "C"
                    ElseIf ch = ">" Then
                            If stT = "" Then
                                    ScanTag = -ich
                                    Exit Function
                            End If
                            dict.Item("T") = stT
                            ScanTag = ich
                            Exit Function
                    ElseIf ch = "/" Then
                            If Mid(st, ich, 1) = ">" Then
                                    If stT = "" Then
                                            ScanTag = -ich
                                            Exit Function
                                    End If
                                    dict.Item("T") = stT
                                    state = "H"
                            Else
                                    stT = stT & ch
                            End If
                    Else
                            stT = stT & ch
                    End If
            Case "C"        ' "<TAGNAME "
                    If Not IsSpace(ch) Then
                            ich = ich - 1
                            state = "D"
                            stA = ""
                    End If
            Case "D"        ' "<TAGNAME X"
                    If IsSpace(ch) Or ch = ">" Or ch = "/" Then
                            dict.Item("A:" & stA) = True
                            ' Don't reset stA here - there may be a "=" coming
                            ' up and we need to set a real value.
                    End If
                    If IsSpace(ch) Then
                            state = "D1"
                    ElseIf ch = "/" Then
                            dict.Item("A:" & stA) = True
                            state = "H"
                    ElseIf ch = ">" Then
                            dict.Item("A:" & stA) = True
                            ScanTag = ich
                            Exit Function
                    ElseIf ch = "=" Then
                            state = "D2"
                    Else
                            stA = stA & ch
                    End If
            Case "D1"
                    If ch = "=" Then
                            state = "D2"
                    ElseIf Not IsSpace(ch) Then
                            ich = ich - 1
                            state = "C"
                    End If
            Case "D2"       ' "<TAGNAME ATTRIB="
                    If Not IsSpace(ch) Then
                            ich = ich - 1
                            state = "E"
                    End If
            Case "E"
                    If ch = """" Then
                            state = "F"
                    Else
                            ich = ich - 1
                            state = "E2"
                    End If
            Case "E2"
                    If ch = ">" Then
                            dict.Item("A:" & stA) = stV
                            ScanTag = ich
                            Exit Function
                    ' Need 1 char look ahead to distinguish <FOO X=/> from
                    ' <FOO X=/B>!
                    ElseIf ch = "/" And Mid(st, ich, 1) = ">" Then
                            dict.Item("A:" & stA) = stV
                            state = "H"
                    ElseIf IsSpace(ch) Then
                            dict.Item("A:" & stA) = stV
                            stA = ""
                            stV = ""
                            state = "C"
                    Else
                            stV = stV & ch
                    End If
            Case "F"
                    If ch = """" Then
                            state = "G"
                    Else
                            stV = stV & ch
                    End If
            Case "G"
                    If IsSpace(ch) Or ch = ">" Or ch = "/" Then
                            dict.Item("A:" & stA) = stV
                            stA = ""
                            stV = ""
                    End If
                    If ch = """" Then
                            stV = stV & ch
                            state = "F"
                    ElseIf IsSpace(ch) Then
                            state = "C"
                    ElseIf ch = ">" Then
                            ScanTag = ich
                            Exit Function
                    ElseIf ch = "/" Then
                            state = "H"
                    Else
                            ScanTag = -ich
                            Exit Function
                    End If
            Case "H"
                    ' DO NOT ALLOW <Foo/   > - makes lookahead in other
                    ' parts of the scanner too difficult; require <FOO/>.
                    If ch = ">" Then
                            dict.Item("U") = True
                            ScanTag = ich
                            Exit Function
                    Else
                            ScanTag = -ich
                            Exit Function
                    End If
            End Select
    Loop
    ScanTag = -ich
End Function

' Convert back to XML format.  E.g.:
' <XML ATTR=VALUE>
'     <A ATTR=VALUE>
'         Body
'         <UNIT FOO/>
'     </A>
' </XML>
Function StXML(ByRef dict, level)
        Dim st
        Dim rgKeys
        Dim iKey
        Dim ich
        Dim fHasChildren

        st = Space(4 * level) & "<" & dict.Item("T")

        rgKeys = dict.Keys
        For iKey = 0 To dict.Count - 1
                If Mid(rgKeys(iKey), 1, 1) = "A" Then
                        st = st & " " & Mid(rgKeys(iKey), 3)
                        If dict.Item(rgKeys(iKey)) <> True Then
                                ' TODO: Need to quote strings with embedded spaces, quotes, etc.
                                st = st & "=" & QuoteString(dict.Item(rgKeys(iKey)), True)
                        End If
                End If
        Next

        If dict.Exists("U") Then
                st = st & "/>" & Chr(13) & Chr(10)
                StXML = st
                Exit Function
        End If

        st = st & ">"
        If dict.Exists("B") Then
                st = st & QuoteString(dict.Item("B"), False)
        End If

        For iKey = 0 To dict.Count - 1
                If Mid(rgKeys(iKey), 1, 1) = "X" Then
                        If Not fHasChildren Then
                            st = st & Chr(13) & Chr(10)
                            fHasChildren = True
                        End If
                        st = st & StXML(dict.Item(rgKeys(iKey)), level + 1)
                End If
        Next
        
        If fHasChildren Then
            st = st & Space(4 * level)
        End If

        st = st & "</" & dict.Item("T") & ">" & Chr(13) & Chr(10)
        StXML = st
End Function

Function UnquoteString(st, ByRef ich)
    Dim ichLast
    Dim ichOrig
    Dim stRet
    Dim ichQuote

    ichOrig = ich
    ichLast = Len(st)
    ich = ich + 1
    ichQuote = InStr(ich, st, """")
    Do While ichQuote <> 0
            stRet = stRet & Mid(st, ich, ichQuote - ich)
            ich = ichQuote + 1
            If ich <= ichLast And Mid(st, ich, 1) = """" Then
                stRet = stRet & """"
                ich = ich + 1
            Else
                UnquoteString = stRet
                Exit Function
            End If
            ichQuote = InStr(ich, st, """")
    Loop

    ' Unbalanced quotes - return failure as negative position of first quote
    ich = -ichOrig
End Function

Function IsSpace(ch)
        Dim wCh

        wCh = Asc(ch)
        IsSpace = (ch = " " Or wCh = 9 Or wCh = 10 Or wCh = 13)
End Function

Function SkipSpaces(st, ich)
        Dim ichLast

        ichLast = Len(st)
        Do While ich <= ichLast
                If Not IsSpace(Mid(st, ich, 1)) Then
                        SkipSpaces = ich
                        Exit Function
                End If
                ich = ich + 1
        Loop

        SkipSpaces = ich
End Function

Function LineNumber(st, ich, ichPosition)
	Dim iln
	
	iln = 1

	Do While ich <= ichPosition
		if Asc(Mid(st, ich, 1)) = 13 then
			iln = iln+1
		end if
		ich = ich+1
	Loop
	
	LineNumber = iln
end Function

Function TrimSpace(st)
        Dim ichLast
        Dim ich
        Dim ichFinal
        Dim ichFirst
        Dim stOut

        ichFirst = 0
        ichLast = Len(st)
        ich = 1
        Do While (ich <= ichLast)
                If Not IsSpace(Mid(st, ich, 1)) Then
                    ichFinal = ich
	                If ichFirst = 0 Then
	                        ichFirst = ich
	                End If
                End If
                ich = ich + 1
        Loop

        If ichFirst = 0 Then
                TrimSpace = ""
                Exit Function
        End If

        TrimSpace = Mid(st, ichFirst, ichFinal - ichFirst + 1)
End Function

Function QuoteString(st, fQuoteSpace)
    Dim stOut
    Dim fQuote
    
    fQuote = InStr(st, """") Or InStr(st, "<") Or InStr(st, "&") Or _
        (fQuoteSpace And InStr(st, " "))
    
    If fQuote Then
        stOut = """" & StReplace(st, """", """""") & """"
    Else
        stOut = st & ""
    End If
    QuoteString = stOut
End Function

Function StReplace(stString, stPattern, stReplacement)
    Dim st
    Dim ich
    Dim ichFind

    ich = 1
    ichFind = InStr(ich, stString, stPattern)
    Do While ichFind <> 0
        st = st & Mid(stString, ich, ichFind - ich) & stReplacement
        ich = ichFind + Len(stPattern)
        ichFind = InStr(ich, stString, stPattern)
    Loop
    st = st & Mid(stString, ich)
    StReplace = st
End Function

%>
